using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;
using WebIdlParser;
using Attribute = WebIdlParser.Attribute;

namespace WebIdlSourceGenerator
{
	internal class Compiler
	{
		private readonly ILookup<string, Definition> fileNameLookup;
		private readonly ImmutableHashSet<(string type, string member)> existingMembers;
		private readonly ILookup<string, InterfaceMixinDefinition> mixinLookup;
		private readonly IReadOnlyDictionary<string, TypedefDefinition> typedefDict;

		private static string Throw()
		{
			_ = Debugger.Launch();
			throw new Exception();
		}

		public Compiler(ImmutableArray<(string fileName, Definition definition)> definitionsWithFileNames, ImmutableArray<(string type, string member)> existingMembers)
		{
			fileNameLookup = definitionsWithFileNames.ToLookup(x => x.fileName, x => x.definition);
			this.existingMembers = existingMembers.ToImmutableHashSet();

			mixinLookup =
				definitionsWithFileNames
				.Select(x => x.definition)
				.Select(x => x switch { Partial p => p.Definition, _ => x })
				.OfType<InterfaceMixinDefinition>()
				.ToLookup(x => x.Name)
				;

			typedefDict =
				definitionsWithFileNames
				.Select(x => x.definition)
				.OfType<TypedefDefinition>()
				.ToDictionary(x => x.Name);
		}

		internal IEnumerable<(string name, string contents)> Compile()
		{
			foreach (var group in fileNameLookup)
			{
				yield return (group.Key, Output(group));
			}
		}

		private string Output(IEnumerable<Definition> definitions)
		{
			return
				$$"""
				// <auto-generated/>
				#nullable enable
				namespace WebView2.DOM;
				{{string.Join("", definitions.Select(x => Output(x)))}}
				""";
		}

		private string Output(Definition definition, bool isPartial = false)
		{
			return definition switch
			{
				Partial x => Output(x.Definition, isPartial: true),

				CallbackFunctionDefinition x => Output(x),
				CallbackInterfaceDefinition x => Output(x),
				DictionaryDefinition x => Output(x),
				EnumDefinition x => Output(x),
				IncludesDefinition x => Output(x),
				InterfaceDefinition x => Output(x, isPartial),
				InterfaceMixinDefinition x => Output(x),
				NamespaceDefinition x => Output(x),
				TypedefDefinition => "",

				_ => $"#error Couldn't generate code for definition of type {definition.GetType()}",
			};
		}

		private string Output(CallbackFunctionDefinition callback)
		{
			var name = callback.Name;
			var returnType = Output(callback.ReturnType);
			var argumentsWithTypes = OutputWithTypes(callback.Arguments);

			return
				$$"""


				public delegate {{returnType}} @{{name}} ({{argumentsWithTypes}});
				""";
		}

		private string Output(CallbackInterfaceDefinition callbackInterface)
		{
			var operation = callbackInterface.Members.OfType<Operation>().Single();

			var name = callbackInterface.Name;
			var returnType = Output(operation.ReturnType);
			var argumentsWithTypes = OutputWithTypes(operation.Arguments);

			return
				$$"""


				public delegate {{returnType}} @{{name}} ({{argumentsWithTypes}});
				""";
		}

		private string Output(DictionaryDefinition dictionary)
		{
			var name = dictionary.Name;
			var inheritance = dictionary.Inheritance switch
			{
				null => " : JsDictionary",
				var x => $" : {x}"
			};
			var members = string.Join("", dictionary.Members.Select(member => Output(name, member)));

			return
				$$"""


				[global::System.Text.Json.Serialization.JsonConverter(typeof(Converter))]
				public partial record {{name}}{{inheritance}}
				{
					private class Converter : Converter<{{name}}> { }

				{{members}}
				}
				""";
		}

		private string Output(string parentType, DictionaryMember member)
		{
			if (existingMembers.Contains((parentType, member.Name)))
			{
				return "";
			}

			var type = Output(member.Type);
			var nullableType =
				type.EndsWith("?")
				? type
				: $"{type}?";
			var name = member.Name;

			if (member is RequiredDictionaryMember)
			{
				return
					$$"""


						public required {{type}} @{{name}}
						{
							get => GetRequired<{{type}}>();
							init => Set(value);
						}
					""";
			}
			else if (member is OptionalDictionaryMember optional)
			{
				var defaultValue =
					optional.DefaultValue switch
					{
						null => "default",
						"[ ]" => $"({type}){type.Replace("System.Collections.Generic.IReadOnlyList", "System.Collections.Immutable.ImmutableArray")}.Empty",
						var x when nullableType is not "string?" && x.StartsWith("\"") => $"{type}.{OutputEnumValueIdentifier(x)}",
						var x => x,
					};


				return
					$$"""


						public {{type}} @{{name}}
						{
							get => Get<{{type}}>(defaultValue: {{defaultValue}});
							init => Set(value);
						}
					""";
			}
			else
			{
				return
					$$"""


						public {{type}} @{{name}}
						{
							get => GetRequired<{{type}}>();
							init => Set(value);
						}
					""";
			}
		}

		private string Output(TypeWithExtendedAttributes type)
		{
			return Output(type.Type);
		}

		private string Output(WebIdlParser.Type type)
		{
			var typeName = type switch
			{
				UnionType x => $"global::OneOf.OneOf<{string.Join(", ", x.Types.Select(y => Output(y)))}>",

				Any => "any",
				WebIdlParser.Object => "object",
				Undefined => "void",

				WebIdlParser.Boolean => "bool",
				WebIdlParser.Byte => "sbyte",
				WebIdlParser.Octet => "byte",
				WebIdlParser.BigInt => "global::System.BigInteger",
				WebIdlParser.Float => "float",
				WebIdlParser.Double => "double",
				WebIdlParser.Short => "short",
				WebIdlParser.Long => "int",
				WebIdlParser.LongLong => "long",
				WebIdlParser.UnrestrictedFloat => "float",
				WebIdlParser.UnrestrictedDouble => "double",
				WebIdlParser.UnsignedShort => "ushort",
				WebIdlParser.UnsignedLong => "uint",
				WebIdlParser.UnsignedLongLong => "ulong",

				ByteString => "string",
				DOMString => "string",
				USVString => "string",

				GenericType { Name: "sequence" } x => $"global::System.Collections.Generic.IReadOnlyList<{string.Join(", ", x.TypeParameters.Select(y => Output(y)))}>",
				GenericType { Name: "FrozenArray" } x => $"global::System.Collections.Generic.IReadOnlyList<{string.Join(", ", x.TypeParameters.Select(y => Output(y)))}>",

				GenericType { Name: "record" } x => $"global::System.Collections.Generic.IReadOnlyDictionary<{string.Join(", ", x.TypeParameters.Select(y => Output(y)))}>",

				GenericType { Name: "Promise" } x when x.TypeParameters[0].Type is Undefined => "VoidPromise",

				GenericType x => $"{x.Name}<{string.Join(", ", x.TypeParameters.Select(y => Output(y)))}>",

				WebIdlParser.Type { Name: "WindowProxy" } x => "Window",
				WebIdlParser.Type x =>
					typedefDict.TryGetValue(x.Name, out var typedef)
					? Output(typedef.Type)
					: x.Name
					,
			};

			return type.IsNullable ? $"{typeName}?" : typeName;
		}

		private string Output(EnumDefinition @enum)
		{
			return
				$$"""


				public enum {{@enum.Name}}
				{
				{{string.Join("", @enum.Values.Select(value =>
				$$"""
					/// <summary>
					/// {{value}}
					/// </summary>
					[global::System.Runtime.Serialization.EnumMember(Value = {{value}})] {{OutputEnumValueIdentifier(value)}},


				"""))}}
				}
				""";
		}

		private string OutputEnumValueIdentifier(string value) =>
			$"@{Regex.Replace(value.Replace("\"", ""), "[^A-Za-z0-9_]", "_")}";

		private string Output(IncludesDefinition includes)
		{
			var name = includes.Interface;
			var inherits = includes.Mixin;

			var members =
				string.Join("",
					mixinLookup[includes.Mixin]
					.SelectMany(x => x.Members)
					.Select(member => Output(inherits, member)));

			return
				$$"""


				public partial class {{name}} : {{inherits}}
				{
				{{members}}
				}
				""";
		}

		private string Output(InterfaceDefinition @interface, bool isPartial)
		{
			var name = @interface.Name;

			string inheritance;
			string constructor;

			if (isPartial)
			{
				inheritance = "";
				constructor = "";
			}
			else
			{
				inheritance = $" : {@interface.Inheritance ?? "JsObject"}";

				var constructorMember =
					@interface.Members
					.OfType<Constructor?>()
					.SingleOrDefault();

				constructor = Output(name, constructorMember);
			}


			var interfacesList = new List<string>();

			if (@interface.ExtendedAttributes.Any(x => x is ExtendedAttributeNoArgs && x.Name == "Transferable"))
			{
				interfacesList.Add("Transferable");
			}

			if (@interface.Members.OfType<Iterable?>().SingleOrDefault() is {/*notnull*/} iterable)
			{
				if (iterable.TypeArguments.Length == 2)
				{
					var type = $"global::System.Collections.Generic.KeyValuePair<{Output(iterable.TypeArguments[0])}, {Output(iterable.TypeArguments[1])}>";

					interfacesList.Add($"global::System.Collections.Generic.IEnumerable<{type}>");
				}
			}

			var interfaces = string.Join("", interfacesList.Select(x => $", {x}"));

			var eventInvoke =
				@interface.Inheritance?.EndsWith("Event") == true
				? "	internal override void Invoke(EventTarget eventTarget, global::System.Delegate handler) => GenericInvoke(eventTarget, handler, this);"
				: ""
				;

			var indexerGroups =
				@interface.Members
				.Where(x => x is Getter or Setter or Deleter)
				.GroupBy(x => x switch
				{
					Getter getter => getter.Operation.Arguments[0].Type.Type.Name,
					Setter setter => setter.Operation.Arguments[0].Type.Type.Name,
					Deleter deleter => deleter.Operation.Arguments[0].Type.Type.Name,
					_ => Throw(),
				});

			var indexers =
				string.Join("",
					indexerGroups.Select(x => Output(new Indexer
					{
						Getter = x.OfType<Getter>().Single(),
						Setter = x.OfType<Setter>().SingleOrDefault(),
						Deleter = x.OfType<Deleter>().SingleOrDefault(),
					})));

			var members = string.Join("", @interface.Members.Select(member => Output(name, member)));

			return
				$$"""


				{{(@interface.Members.OfType<Iterable>().Any() ? "[global::System.Diagnostics.DebuggerTypeProxy(typeof(JsCollectionProxy))]" : "")}}
				public partial class {{name}}{{inheritance}}{{interfaces}}
				{
				{{constructor}}
				{{eventInvoke}}
				{{indexers}}
				{{members}}
				}
				""";
		}

		private string Output(InterfaceMixinDefinition mixin)
		{
			var name = mixin.Name;

			var members = string.Join("", mixin.Members.Select(member => OutputMixinMember(name, member)));

			return
				$$"""


				public partial interface {{name}}
				{
				{{members}}
				}
				""";
		}

		private string Output(NamespaceDefinition x) => Throw();

		private object Output(Indexer indexer)
		{
			var returnType = Output(indexer.Getter.Operation.ReturnType);
			var indexType = Output(indexer.Getter.Operation.Arguments[0].Type);
			var indexName = indexer.Getter.Operation.Arguments[0].Name;

			var getter =
				$"get => IndexerGet<{returnType}>(@{indexName});";

			var setter =
				indexer.Setter is null ? "" :
				$"set => IndexerSet(@{indexName}, value);";

			var deleter =
				indexer.Deleter is null ? "" :
				$"public void Remove({indexType} @{indexName}) => IndexerDelete(@{indexName});";

			return
				$$"""
					public {{returnType}} this[{{indexType}} @{{indexName}}]
					{
						{{getter}}
						{{setter}}
					}
					{{deleter}}
				""";
		}

		private string Output(string parentType, Member member, bool isStatic = false)
		{
			return member switch
			{
				StaticMember x => Output(parentType, x.Member, isStatic: true),

				AsyncIterable x => Output(x),
				StringifierAttribute x => Output(x),
				Attribute x => Output(parentType, x),
				Const x => Output(parentType, x),
				Iterable x => Output(x),
				Maplike x => Output(x),
				Operation x => Output(parentType, x, isStatic),
				Setlike x => Output(x),
				Stringifier x => Output(x),

				Constructor => "",
				Setter => "",
				Getter => "",
				Deleter => "",

				_ => $"#error Couldn't generate code for member of type {member.GetType()}",
			};
		}

		private string Output(StaticMember x) => Throw();

		private string Output(AsyncIterable x) => Throw();

		private string Output(string parentType, Attribute attribute)
		{
			if (existingMembers.Contains((parentType, attribute.Name)))
			{
				return "";
			}

			if (IsEvent(attribute))
			{
				return OutputEvent(parentType, attribute);
			}

			var special = attribute switch
			{
				InheritAttribute => " new",
				_ => "",
			};

			var type = Output(attribute.Type);
			var returnType = type is "any" ? "dynamic" : type;
			var name = attribute.Name;

			if (type is "OnErrorEventHandler" or "OnBeforeUnloadEventHandler")
			{
				return "";
			}

			if (attribute.ExtendedAttributes.Any(x => x is ExtendedAttributeNoArgs && x.Name == "SameObject"))
			{
				return
					$$"""

						public{{special}} {{returnType}} @{{name}} => GetCached<{{type}}>();
					""";
			}
			else if (attribute.IsReadOnly)
			{
				return
					$$"""

						public{{special}} {{returnType}} @{{name}} => Get<{{type}}>();
					""";
			}
			else
			{
				return
					$$"""

						public{{special}} {{returnType}} @{{name}} { get => Get<{{type}}>(); set => Set(value); }
					""";
			}
		}

		private bool IsEvent(WebIdlParser.Attribute attribute) =>
			attribute.Type.Type.Name == "EventHandler"
			&&
			attribute.Name.StartsWith("on");

		private string OutputEvent(string parentType, WebIdlParser.Attribute attribute)
		{
			try
			{
				var eventTypeName = EventMap.GetEventTypeName(parentType, attribute.Name);
				var name = attribute.Name;

				return
					$$"""

						public event global::System.EventHandler<{{eventTypeName}}> @{{name}} { add => AddEvent(value); remove => RemoveEvent(value); }
					""";
			}
			catch
			{
				return
					$$"""

					#error Couldn't find type information for {{parentType}}.{{attribute.Name}}.
					""";
			}
		}

		private string Output(string parentType, Const constant)
		{
			if (existingMembers.Contains((parentType, constant.Name)))
			{
				return "";
			}

			var name = constant.Name;
			var type = Output(constant.Type);
			var value = constant.Value;

			return
				$$"""

					public const {{type}} @{{name}} = {{value}};
				""";
		}

		private string Output(string parentType, Constructor? constructor)
		{
			if (constructor is not null)
			{
				var outputs = new StringBuilder();

				foreach (var arguments in UnfoldArguments(constructor.Arguments))
				{
					var argumentsWithTypes = OutputWithTypes(arguments);
					var argumentsWithoutTypes = OutputWithoutTypes(arguments);

					_ = outputs.Append(
						$$"""
							public {{parentType}}({{argumentsWithTypes}}) =>
								Construct({{argumentsWithoutTypes}});

						""");
				}

				return outputs.ToString();
			}
			else
			{
				return
					$$"""
						private protected {{parentType}}() { }

					""";
			}
		}

		private string Output(Iterable iterable)
		{
			if (iterable.TypeArguments.Length == 2)
			{
				var type = $"global::System.Collections.Generic.KeyValuePair<{Output(iterable.TypeArguments[0])}, {Output(iterable.TypeArguments[1])}>";

				return
					$$"""

						public Iterator GetEnumerator() => SymbolMethod<Iterator>("iterator").Invoke();
						global::System.Collections.Generic.IEnumerator<{{type}}> global::System.Collections.Generic.IEnumerable<{{type}}>.GetEnumerator() => GetEnumerator();
						global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
						public class Iterator : Iterator<{{type}}> { }
					""";
			}
			else
			{
				return Throw();
			}
		}

		private string Output(Maplike x) => Throw();

		private string Output(string parentType, Operation operation, bool isStatic)
		{
			if (operation.Name is not null && existingMembers.Contains((parentType, operation.Name)))
			{
				return "";
			}

			var @static = isStatic ? " static" : "";
			var returnType = Output(operation.ReturnType);
			var name = operation.Name;

			//var requiredArguments = new List<Argument>();
			//var optionalArgumentLists = new List<ImmutableArray<Argument>> { ImmutableArray<Argument>.Empty };

			//var enumerator = operation.Arguments.GetEnumerator();

			//while (enumerator.MoveNext())
			//{
			//	var current = enumerator.Current;

			//	if (current is not OptionalArgument)
			//	{
			//		requiredArguments.Add(current);
			//	}
			//	else
			//	{
			//		var previous = optionalArgumentLists[^1];
			//		optionalArgumentLists.Add(previous.Add(current));
			//		goto optional;
			//	}
			//}

			//optional:
			//while (enumerator.MoveNext())
			//{
			//	var current = enumerator.Current;

			//	if (current is OptionalArgument)
			//	{
			//		var previous = optionalArgumentLists[^1];
			//		optionalArgumentLists.Add(previous.Add(current));
			//	}
			//	else
			//	{
			//		return $"#error Couldn't generate code for operation {name}";
			//	}
			//}

			var outputs = new StringBuilder();

			foreach (var arguments in UnfoldArguments(operation.Arguments))
			{
				var argumentsWithTypes = OutputWithTypes(arguments);
				var argumentsWithoutTypes = OutputWithoutTypes(arguments);

				var Method = (isStatic, operation.ReturnType) switch
				{
					(true, Undefined) => "StaticMethod",
					(false, Undefined) => "Method",
					(true, _) => $"StaticMethod<{returnType}>",
					(false, _) => $"Method<{returnType}>",
				};

				_ = outputs.Append(
					$$"""

						public{{@static}} {{returnType}} @{{name}}({{argumentsWithTypes}}) => {{Method}}().Invoke({{argumentsWithoutTypes}});
					""");
			}

			//foreach (var optionalArguments in optionalArgumentLists)
			//{
			//	foreach (var arguments in UnfoldUnionTypes(requiredArguments.Concat(optionalArguments)))
			//	{
			//		var argumentsWithTypes = OutputWithTypes(arguments);
			//		var argumentsWithoutTypes = OutputWithoutTypes(arguments);

			//		var Method = (isStatic, operation.ReturnType) switch
			//		{
			//			(true, Undefined) => "StaticMethod",
			//			(false, Undefined) => "Method",
			//			(true, _) => $"StaticMethod<{returnType}>",
			//			(false, _) => $"Method<{returnType}>",
			//		};

			//		_ = outputs.Append(
			//			$$"""

			//				public{{@static}} {{returnType}} @{{name}}({{argumentsWithTypes}}) => {{Method}}().Invoke({{argumentsWithoutTypes}});
			//			""");
			//	}
			//}

			return outputs.ToString();
		}







		private IEnumerable<IEnumerable<Argument>> UnfoldArguments(ImmutableArray<Argument> arguments)
		{
			var requiredArguments = new List<Argument>();
			var optionalArgumentLists = new List<ImmutableArray<Argument>> { ImmutableArray<Argument>.Empty };

			var enumerator = arguments.GetEnumerator();

			while (enumerator.MoveNext())
			{
				var current = enumerator.Current;

				if (current is not OptionalArgument)
				{
					requiredArguments.Add(current);
				}
				else
				{
					var previous = optionalArgumentLists[^1];
					optionalArgumentLists.Add(previous.Add(current));
					goto optional;
				}
			}

			optional:
			while (enumerator.MoveNext())
			{
				var current = enumerator.Current;

				if (current is OptionalArgument)
				{
					var previous = optionalArgumentLists[^1];
					optionalArgumentLists.Add(previous.Add(current));
				}
				else
				{
					_ = Throw();
					throw new Exception();
				}
			}

			foreach (var optionalArguments in optionalArgumentLists)
			{
				foreach (var unfoldedArguments in UnfoldUnionTypes(requiredArguments.Concat(optionalArguments)))
				{
					yield return unfoldedArguments;
				}
			}
		}








		private class Node
		{
			public required Argument Current { get; init; }
			public required ImmutableArray<Node> Next { get; init; }
		}

		private IEnumerable<IEnumerable<Argument>> UnfoldUnionTypes(IEnumerable<Argument> arguments)
		{
			if (!arguments.Any()) { return ImmutableArray.Create<IEnumerable<Argument>>(ImmutableArray<Argument>.Empty); }

			var argumentLinkedList = new LinkedList<Argument>(arguments);

			var currentLL = argumentLinkedList.Last;

			var currentNodes =
				(currentLL.Value.Type.Type switch
				{
					UnionType x =>
						x.Types
						.Select(y => new Argument
						{
							ExtendedAttributes = currentLL.Value.ExtendedAttributes,
							Name = currentLL.Value.Name,
							Type = y
						})
						.ToImmutableArray(),

					var x => ImmutableArray.Create(currentLL.Value),
				})
				.Select(x => new Node { Current = x, Next = ImmutableArray<Node>.Empty })
				.ToImmutableArray();

			while (currentLL.Previous is not null)
			{
				var previousLL = currentLL.Previous;

				var previousNodes =
					(previousLL.Value.Type.Type switch
					{
						UnionType x =>
							x.Types
							.Select(y => new Argument
							{
								ExtendedAttributes = previousLL.Value.ExtendedAttributes,
								Name = previousLL.Value.Name,
								Type = y
							})
							.ToImmutableArray(),

						var x => ImmutableArray.Create(previousLL.Value),
					})
					.Select(x => new Node { Current = x, Next = currentNodes })
					.ToImmutableArray();

				currentLL = previousLL;
				currentNodes = previousNodes;
			}

			return ComputePaths(currentNodes);
		}

		private IEnumerable<IEnumerable<Argument>> ComputePaths(IEnumerable<Node> roots)
		{
			foreach (var root in roots)
			{
				foreach (var path in ComputePaths(root))
				{
					yield return path;
				}
			}
		}

		private IEnumerable<IEnumerable<Argument>> ComputePaths(Node root)
		{
			var children = root.Next;

			if (children.Length > 0)
			{
				foreach (var child in children)
				{
					foreach (var path in ComputePaths(child))
					{
						yield return x();
						IEnumerable<Argument> x()
						{
							yield return root.Current;
							foreach (var item in path)
							{
								yield return item;
							}
						}
					}
				}
			}
			else
			{
				yield return x();
				IEnumerable<Argument> x()
				{
					yield return root.Current;
				}
			}
		}




		private string Output(Setlike x) => Throw();

		private string Output(Stringifier x) => Throw();

		private string Output(StringifierAttribute x) => Throw();

		private string OutputMixinMember(string parentType, Member member)
		{
			return member switch
			{
				WebIdlParser.Const x => OutputMixinMember(x),
				WebIdlParser.StringifierAttribute x => OutputMixinMember(x),
				WebIdlParser.Stringifier x => OutputMixinMember(x),
				WebIdlParser.Attribute x => OutputMixinMember(parentType, x),
				WebIdlParser.Operation x => OutputMixinMember(x),

				_ => $"#error Couldn't generate code for mixin member of type {member.GetType()}",
			};
		}

		private string OutputMixinMember(Const x) => Throw();

		private string OutputMixinMember(WebIdlParser.StringifierAttribute x) => Throw();

		private string OutputMixinMember(Stringifier x) => Throw();

		private string OutputMixinMember(string parentType, WebIdlParser.Attribute attribute)
		{
			if (IsEvent(attribute))
			{
				return OutputMixinEvent(parentType, attribute);
			}

			var type = Output(attribute.Type);
			var name = attribute.Name;

			if (type is "OnErrorEventHandler" or "OnBeforeUnloadEventHandler")
			{
				return "";
			}

			if (attribute.IsReadOnly)
			{
				return
					$$"""

						{{type}} @{{name}} { get; }
					""";
			}
			else
			{
				return
					$$"""

						{{type}} @{{name}} { get; set; }
					""";
			}
		}

		private string OutputMixinEvent(string parentType, WebIdlParser.Attribute attribute)
		{
			try
			{
				var eventTypeName = EventMap.GetEventTypeName(parentType, attribute.Name);
				var name = attribute.Name;

				return
					$$"""

						event global::System.EventHandler<{{eventTypeName}}> @{{name}};
					""";
			}
			catch
			{
				return
					$$"""

					#error Couldn't find type information for {{parentType}}.{{attribute.Name}}.
					""";
			}
		}

		private string OutputMixinMember(Operation operation)
		{
			var returnType = Output(operation.ReturnType);
			var name = operation.Name;

			var requiredArguments = new List<Argument>();
			var optionalArgumentLists = new List<ImmutableArray<Argument>> { ImmutableArray<Argument>.Empty };

			var enumerator = operation.Arguments.GetEnumerator();

			while (enumerator.MoveNext())
			{
				var current = enumerator.Current;

				if (current is not OptionalArgument)
				{
					requiredArguments.Add(current);
				}
				else
				{
					var previous = optionalArgumentLists[^1];
					optionalArgumentLists.Add(previous.Add(current));
					goto optional;
				}
			}

			optional:
			while (enumerator.MoveNext())
			{
				var current = enumerator.Current;

				if (current is OptionalArgument)
				{
					var previous = optionalArgumentLists[^1];
					optionalArgumentLists.Add(previous.Add(current));
				}
				else
				{
					return $"#error Couldn't generate code for operation {name}";
				}
			}

			var outputs = new StringBuilder();

			foreach (var optionalArguments in optionalArgumentLists)
			{
				var argumentsWithTypes = OutputWithTypes(requiredArguments.Concat(optionalArguments));

				_ = outputs.Append(
					$$"""

						{{returnType}} @{{name}}({{argumentsWithTypes}});
					""");
			}

			return outputs.ToString();
		}

		private string OutputWithTypes(IEnumerable<Argument> arguments)
		{
			return string.Join(", ", arguments.Select(x => OutputWithType(x)));
		}

		private string OutputWithType(Argument x)
		{
			var type = Output(x.Type);
			if (type is "any") { type = "object?"; }

			return $"{type} @{x.Name}";
		}

		private string OutputWithoutTypes(IEnumerable<Argument> arguments)
		{
			return string.Join(", ", arguments.Select(x => OutputWithoutType(x)));
		}

		private string OutputWithoutType(Argument x)
		{
			return $"@{x.Name}";
		}
	}
}